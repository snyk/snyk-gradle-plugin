import groovy.json.JsonOutput

// This script does the following: for all the projects in the build file,
// generate a merged configuration of all the available configurations,
// and then list the dependencies as a tree.

// It's the responsibility of the caller to pick the project(s) they are
// interested in from the results.

// CLI usages:
// gradle -q -I init.gradle snykResolvedDepsJson
// gradle -q -I init.gradle snykResolvedDepsJson -Pconfiguration=specificConf

// (-q to have clean output, -P supplies args as per https://stackoverflow.com/a/48370451)

// Output format:
// Since Gradle is chatty and often prints a "Welcome" banner even with -q option,
// the only output line that matters is prefixed with "JSONDEPS " and is a JSON representation
// of the dependencies trees for all projects in the following format

// interface JsonDepsScriptResult {
//   defaultProject: string;
//   projects: ProjectsDict;
// }
// interface ProjectsDict {
//   [project: string]: GradleProjectInfo;
// }

// interface GradleProjectInfo {
//   depDict: DepDict;
//   targetFile: string;
// }
// export interface DepDict {
//   [name: string]: DepTree;
// }
// interface DepTree {
//   name: string;
//   version: string;
//   dependencies?: DepDict;
// }

// We are attaching this task to every project, as this is the only reliable way to run it
// when we start with a subproject build.gradle. As a consequence, we need to make sure we
// only ever run it once, for the "starting" project.
def snykMergedDepsConfExecuted = false
allprojects { everyProj ->
    task snykResolvedDepsJson {
        def onlyConf = project.hasProperty('configuration') ? configuration : null

        // currentChain is a protection against dependency cycles, which are perfectly normal in Java/Gradle world
        def depsToDict
        depsToDict = { Iterable deps, Set currentChain ->
            def res = [:]
            deps.each { d ->
                def depName = "$d.moduleGroup:$d.moduleName"
                if (!currentChain.contains(depName)) {
                    def row = ['name': depName, 'version': d.moduleVersion]
                    currentChain.add(depName)
                    def subDeps = depsToDict(d.children, currentChain)
                    currentChain.remove(depName)
                    if (subDeps.size() > 0) {
                        row['dependencies'] = subDeps
                    }
                    res[row['name']] = row
                }
            }
            return res
        }

        doLast { task ->
            def projectsDict = [:]
            def result = ['defaultProject': task.project.name, 'projects': projectsDict]
            if (!snykMergedDepsConfExecuted) {
                allprojects.each { proj ->
                    def snykConf = null
                    if (proj.configurations.size() > 0) {
                        if (onlyConf != null) {
                            // We select one existing configuration, with its attributes.
                            try {
                                snykConf = proj.configurations.getByName(onlyConf)
                            } catch (e) {
                                throw new RuntimeException('Configuration not found: ' + onlyConf +
                                    ', available configurations for project ' + proj + ': '
                                     + proj.configurations.collect { it.name })
                            }
                        } else if (proj.configurations.findAll({ it.name == 'snykMergedDepsConf'}).size() == 0) {
                            // We create a new, "merged" configuration here. It has no attributes, which might be
                            // a problem for Android builds, where a resolution of a dependency "variant"
                            // is often dependent on configuration attributes (such as BuildType or Usage).
                            snykConf = proj.configurations.create('snykMergedDepsConf')
                            proj.configurations
                                .findAll({ it.name != 'snykMergedDepsConf' && (onlyConf == null || it.name == onlyConf) })
                                .each { snykConf.extendsFrom(it) }
                        }
                    }
                    if (snykConf != null) {
                        projectsDict[proj.name] = [
                            'targetFile': findProject(proj.path).buildFile.toString(),
                            'depDict': depsToDict(snykConf.resolvedConfiguration.firstLevelModuleDependencies, new HashSet())
                        ]
                    } else {
                        projectsDict[proj.name] = [
                            'targetFile': findProject(proj.path).buildFile.toString()
                        ]
                    }
                }
                println("JSONDEPS " + JsonOutput.toJson(result))
                snykMergedDepsConfExecuted = true
            }
        }
    }
}
