import groovy.json.JsonOutput

// This script does the following: for all the projects in the build file,
// generate a merged configuration of all the available configurations,
// and then list the dependencies as a tree.

// It's the responsibility of the caller to pick the project(s) they are 
// interested in from the results.

// CLI usages:
// gradle -q -I init.gradle snykResolvedDepsJson
// gradle -q -I init.gradle snykResolvedDepsJson -Pconfiguration=specificConf

// (-q to have clean output, -P supplies args as per https://stackoverflow.com/a/48370451)

// Output format:
// Since Gradle is chatty and often prints a "Welcome" banner even with -q option,
// the only output line that matters is prefixed with "JSONDEPS " and is a JSON representation
// of the dependencies trees for all projects in the following format

// interface JsonDepsScriptResult {
//   defaultProject: string;
//   projects: ProjectsDict;
// }
// interface ProjectsDict {
//   [project: string]: GradleProjectInfo;
// }

// interface GradleProjectInfo {
//   depDict: DepDict;
//   targetFile: string;
// }
// export interface DepDict {
//   [name: string]: DepTree;
// }
// interface DepTree {
//   name: string;
//   version: string;
//   dependencies?: DepDict;
// }

// We are attaching this task to every project, as this is the only reliable way to run it
// when we start with a subproject build.gradle. As a consequence, we need to make sure we
// only ever run it once, for the "starting" project.
def snykMergedDepsConfExecuted = false
allprojects { everyProj ->
    task snykResolvedDepsJson { 
        def onlyConf = project.hasProperty('configuration') ? configuration : null

        def depsToDict
        depsToDict = { deps ->
            def res = [:]
            deps.each { d ->
                def row = ['name': "$d.moduleGroup:$d.moduleName", 'version': d.moduleVersion]
                def subDeps = depsToDict(d.children)
                if (subDeps.size() > 0) {
                    row['dependencies'] = subDeps
                }
                res[row['name']] = row
            }
            return res
        }

        doLast { task ->
            def projectsDict = [:]
            def result = ['defaultProject': task.project.name, 'projects': projectsDict]
            if (!snykMergedDepsConfExecuted) {
                allprojects.each { proj ->
                    if (proj.configurations.size() > 0) {
                        if (proj.configurations.findAll({ it.name == 'snykMergedDepsConf'}).size() == 0) {
                            def snykConf = proj.configurations.create('snykMergedDepsConf')
                            proj.configurations
                                .findAll({ it.name != 'snykMergedDepsConf' && (onlyConf == null || it.name == onlyConf) })
                                .each { snykConf.extendsFrom(it) }
                            projectsDict[proj.name] = [
                                'targetFile': findProject(proj.path).buildFile.toString(),
                                'depDict': depsToDict(snykConf.resolvedConfiguration.firstLevelModuleDependencies)
                            ]
                        }
                    } else {
                        projectsDict[proj.name] = [
                            'targetFile': findProject(proj.path).buildFile.toString()
                        ]
                    }
                }
                println("JSONDEPS " + JsonOutput.toJson(result))
                snykMergedDepsConfExecuted = true
            }
        }
    }
}
